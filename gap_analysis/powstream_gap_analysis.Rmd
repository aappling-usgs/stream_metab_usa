---
title: "Powstream Gap Analysis"
author: "Alison, Appling, Lindsay Carr, Jordan Read"
date: "November 17, 2015"
---

```{r echo=FALSE, warning=FALSE, message=FALSE, error=FALSE, eval=TRUE, results='hide'}

library(unitted)
library(ggplot2)
library(knitr)
library(dplyr)
library(tidyr)

allData_list <- load.gapanalysis.data()

for(i in 1:length(allData_list)){
  eval(parse(text=paste0(names(allData_list)[i], " <- allData_list[[", i, "]]")))
}

```

This analysis will compare conditions at stream sites that have metabolism estimates with all NHDPlus stream sites in the US. The goal is to identify which conditions of US streams have not been fully represented by the collection of current metabolism sites. Identification of such underrepresented conditions will help in choosing 30 new monitoring sites to create a more robust dataset for metabolism estimates. 

Data for NHDPlus streams comes from Mike Wieczorek's *NHDPlus Version 2 Accumulated and Reach Catchment Variables* dataset on ScienceBase. Data representing the current metabolism sites comes from using the `get_meta()` function in `powstreams.R` and has data for the 291 sites with metabolism estimates. Seven metrics have been used in this analysis; additionally, each metric has an *Accumulated Watershed* (watershed down the NHDPlus network at each catchment) density plot and a *Reach Catchment* plot (watershed for each specific NHDPlus catchment).  

  
**Metrics used for this analysis:**

* Population Density
* Agriculture
* Runoff
* Temperature
* Precipitation
* Watershed Area
* Hydrologic Indicator Statistics
* Stream Order
* Ecoregions


```{r echo=FALSE, warning=FALSE, message=FALSE}
allsites_data <- list(allData_land, allData_land_RE, allData_pop, allData_precip, allData_run, allData_temp)
num_allsites <- max(sapply(allsites_data, function(x) {length(unique(x$COMID))}))
num_metabsites <- length(unique(metabData$site_num))
num_sites_table <- data.frame(`Sites`=c(num_metabsites, num_allsites),
                              row.names = c("Metabolism", "All US"))
kable(num_sites_table)
```

\newpage

```{r popdens, echo=FALSE}
```

##Population Density

Population density is based on the 2010 US Population Census and is measured in people per square kilometer. 

```{r echo=FALSE, warning=FALSE, message=FALSE}

df_pop_AC <- format.df("landcover.AC_POPD10", "POPD10_AC", metabData, allData_pop, type=NULL)
df_pop_RE <- format.df("landcover.RE_POPD10", "MEAN", metabData, allData_pop, type=NULL)

df_pop <- format.catchment.df(df_pop_AC, df_pop_RE)
plot.dens(df_pop, "Population Density (2010 US Population Census)", log=TRUE, reach=TRUE, 
          xlabel="Population Density\n(people per square kilometer)")

```


\newpage

```{r agriculture, echo=FALSE}
```

##Agriculture

Data representing agriculture is the sum of the land-use classes 81 (Pasture/Hay) and 82 (Cultivated Crops). The values are shown as the percent of the watershed area covered in pasture/hay or cultivated crops.    

```{r echo=FALSE, warning=FALSE, message=FALSE, fig.width=8, fig.height=5}

df_ag_crop_AC <- format.df("landcover.AC_NLCD11Buffpct82", "ACLU11_82", metabData, allData_land, type="ac_ag")
df_ag_hay_AC <- format.df("landcover.AC_NLCD11Buffpct81", "ACLU11_81", metabData, allData_land, type="ac_ag")
df_ag_AC <- data.frame(data_type = df_ag_crop_AC$data_type, 
                       data_vals = df_ag_crop_AC$data_vals + df_ag_hay_AC$data_vals)

df_ag_crop_RE <- format.df("landcover.RE_NLCD11Buffpct82", "NLCD11_82", metabData, allData_land_RE, type="re_ag")
df_ag_hay_RE <- format.df("landcover.RE_NLCD11Buffpct81", "NLCD11_81", metabData, allData_land_RE, type="re_ag")
df_ag_RE <- data.frame(data_type = df_ag_crop_RE$data_type, 
                       data_vals = df_ag_crop_RE$data_vals + df_ag_hay_RE$data_vals)

df_ag <- format.catchment.df(df_ag_AC, df_ag_RE) 
mainplot <- plot.dens(df_ag, "Fractional Coverage of Agriculture\n(National Land Cover Database 2011)", 
                      log=FALSE, reach=TRUE, xlabel="Fraction of Pasture + Crops in Watershed Area")

rect_df <- data.frame(xmin=0, xmax=0.15, ymin=-Inf, ymax=Inf)
  
secondplot <- mainplot + coord_cartesian(xlim=c(0, 0.15)) + 
    ggtitle("Lower Range of\nFractional Coverage of Agriculture\n(National Land Cover Database 2011")

mainplot <- mainplot + geom_rect(data = rect_df, color="khaki4", alpha=0.3,
                                 aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax)) +
  geom_text(data = data.frame(x1 = 0.25, y1 = 12, label = "See graph below\nfor a closer view"), 
            aes(x = x1, y = y1, label = label))

mainplot
secondplot

```


\newpage

```{r runoff, echo=FALSE}
```

##Runoff

Runoff data is the average estimated runoff based on streamflow records from 1971-2000, and is measured in millimeters (mm). 

Note: no estimation method was reported with this dataset. 

```{r echo=FALSE, warning=FALSE, message=FALSE}

df_run_AC <- format.df("hydrol.RUNOFF_AC", "RUNOFF_AC", metabData, allData_run, type=NULL)
df_run_RE <- format.df("hydrol.RUNOFF_RE", "MEAN", metabData, allData_run, type=NULL)

df_run <- format.catchment.df(df_run_AC, df_run_RE) 
plot.dens(df_run, "Average Runoff\n(1971-2000)", log=TRUE, reach=TRUE,
          xlabel="Runoff (mm)")

```

Note: There are 3,099 runoff values equal to 0 for the accumulated catchments for the entire United States dataset, and 4,757 runoff values equal to 0 for the reach catchments for the entire United States dataset. This skews the density plot for runoff when the values are logged because 0s are treated as NAs.  


\newpage

```{r temp, echo=FALSE}
```

##Temperature

Temperature data is the average annual air temperature (in deg C) from 1971-2000 based on 800 meter PRISM source grids.    

```{r echo=FALSE, warning=FALSE, message=FALSE}

df_temp_AC <- format.df("climate.TMEAN_AC", "TMEAN_AC", metabData, allData_temp, type=NULL)
df_temp_RE <- format.df("climate.TMEAN_RE", "MEAN", metabData, allData_temp, type=NULL)

df_temp <- format.catchment.df(df_temp_AC, df_temp_RE)
plot.dens(df_temp, "Average Temperature\n(1971-2000)", log=FALSE, reach=TRUE,
          xlabel="Temperature (deg C)")

```


\newpage

```{r precip, echo=FALSE}
```

##Precipitation

Precipitation data is the average annual precipitation (cm/year) from 1971-2000 based on 800 meter PRISM data. A correction has been applied to the data coming from Science Base for NHD+ Sites at the reach catchment scale. For the metabolism sites, Ted Stets divided the reach catchment values by 1000; the same correction has been applied for reach-scale precipitation values coming from the NHD+ dataset.

```{r echo=FALSE, warning=FALSE, message=FALSE}

df_precip_AC <- format.df("climate.PPT30YR_AC", "PPT30YR_AC", metabData, allData_precip, type=NULL)
df_precip_RE <- format.df("climate.PPT30YR_RE", "MEAN", metabData, allData_precip, type="re_precip")

df_precip <- format.catchment.df(df_precip_AC, df_precip_RE)
plot.dens(df_precip, "Average Annual Precipitation\n(1971-2000)", log=TRUE, reach=TRUE,
          xlabel="Precipitation (cm)")

```


\newpage

##Watershed Area

The drainage area for either the accumulated watershed or the reach catchment, measured in square meters.

```{r watershed, echo=FALSE, warning=FALSE, message=FALSE}

df_area_AC <- format.df("landcover.ACCUM_AREA", "ACLU_AREA", metabData, allData_land, type=NULL) 
df_area_RE <- format.df("landcover.REACH_AREA", "NLCD11_ARE", metabData, allData_land_RE, type=NULL)

df_area <- format.catchment.df(df_area_AC, df_area_RE)
plot.dens(df_area, "Watershed Areas", log=TRUE, reach=TRUE, xlabel="Watershed Area (sq. meters)")

```

\newpage

##Stream Order

Stream order is a representation of the size and complexity of a stream or river. Stream order values used in this comparison come from NHDPlus, which uses the Strahler stream ordering methodology to calculate stream order values. 

```{r order, echo=FALSE, warning=FALSE, message=FALSE, eval=TRUE}

metab_order <- filter(allData_order, comid %in% metabData$nhdplus_id)
df_order <- format.df("streamorde", "streamorde", metab_order, allData_order, type=NULL) 

plot.orderHist(allData_order, df_order)

```

\newpage

##Hydrologic Indicator Statistics

A collection of hydrologic indicator statistics calculated using streamflow data for the 291 metabolism sites. The R package EflowStats, developed by Jessica Thompson and Stacey Archfield, was used to pull streamflow data from NWIS and calculate the stats. Some of the sites had incomplete data to calculate the statistics (see Table 2 below).   

```{r eflow, echo=FALSE, warning=FALSE, message=FALSE, include=FALSE, eval=FALSE}

#sites must be from the get_meta() because the csv dropped the leading 0

library(EflowStats)

not_working <- c("0166818623", "0166818985", "02110400", "02148315", "02162035",
                 "02336152", "02344630", "03259813", "04119400", "05406469", 
                 "05406479", "08437710", "08447300", "11463682", "11463980", 
                 "11465240", "13173600", "13206400")
working <- which(!metabData$site_num %in% not_working)

#eflow_metab <- eflow.mag7(metabData$site_num[working])
eflow_metab <- read.csv("data(DO_NOT_COMMIT)/eflow_metab.csv")

missing_table <- data.frame(`Site Number`=not_working)

var_table <- data.frame(Variable=c("lam1Obs", "tau2Obs", "tau3Obs", "tau4Obs", 
                                  "ar1Obs", "amplitudeObs", "phaseObs"),
                       Definition=c("Arithmetic mean", 
                                    "Coefficient of L-variation - analagous to coefficient of variation.",
                                    "The third L-moment ratio or L-skew.",
                                    "The fourth L-moment ratio or L-kurtosis.",
                                    "AR1 correlation coefficient.",
                                    "Amplitude of the seasonal signal. Compute seasonality variables by first
                                    standardizing flows, using the fitting relation A*cos(2*pi*t) + B*sin(2*pi*t).",
                                    "Phase of the seasonal signal. Compute seasonality variables by first 
                                    standardizing flows, the fitting relation A*cos(2*pi*t) + B*sin(2*pi*t)."))

```

```{r eflow_plots, echo=FALSE, warning=FALSE, message=FALSE, eval=FALSE}
eflowPlot(eflow_metab, "")

kable(var_table, caption="Table 1. EflowStats variable definitions")

kable(missing_table, caption="Table 2. Metabolism sites not included in hydrologic indicator stats calculations.")

```

##Ecoregions

```{r echo=FALSE, warning=FALSE, message=FALSE, eval=TRUE, results='hide'}


library(rgeos)
library(rgdal)
library(mda.streams)
library(dplyr)
library(unitted)
library(RColorBrewer)
library(httr)

plot.CRS <- "+init=epsg:2163"

missing.data = "#B3B3B3"
site.color = rgb(1,0,0,0.3)


# level III Ecoregions come from GDP geoserver

## -- get spatial data --
# ecoregions:
destination = tempfile(pattern = 'eco_shape', fileext='.zip')
query <- 'http://cida.usgs.gov/gdp/geoserver/wfs?service=WFS&request=GetFeature&typeName=derivative:Level_III_Ecoregions&outputFormat=shape-zip&version=1.0.0'
file <- GET(query, write_disk(destination, overwrite=T), progress())
shp.path <- tempdir()
unzip(destination, exdir = shp.path)
eco = readOGR(shp.path, layer='Level_III_Ecoregions') %>% 
  spTransform(CRS(plot.CRS))

# sites: 
metabDataAll <- get_meta()
metab.sites <- metabDataAll[which(metabDataAll$manual.assessment %in% c("accept", "examine")), ]$site_name

site.loc <- get_site_coords(metab.sites, format="normal")
site.points <- data.frame(lon=site.loc$lon, lat = site.loc$lat)
sp2 <- SpatialPoints(site.points, proj4string=CRS("+proj=longlat + datum=wgs84")) %>% 
  spTransform(CRS(plot.CRS))
## -- get spatial data /--

```

```{r echo=FALSE, eval=TRUE}
## -- analyze point in polygon --
point.in = gContains(eco, sp2, byid=TRUE)

counts.by.id = colSums(point.in)
## -- analyze point in polygon /--


## -- color markers -- 
bins = pretty(counts.by.id, 100)
key.bins = pretty(counts.by.id, 5)
pal = colorRampPalette(brewer.pal(9, 'YlGnBu'))(length(bins))
key.cols = colorRampPalette(brewer.pal(9, 'YlGnBu'))(length(key.bins))
```

```{r echo=FALSE, eval=TRUE}
if (bins[1] != 0 | key.cols[1] != 0)
  #stop('cannot assign zero color when there is no zero value')
pal[1] <- missing.data # 0 is grey
key.cols[1] <- missing.data  # 0 is grey
#get closest bin
bin = unname(sapply(counts.by.id, function(x) ifelse(is.na(x),NA,which.min(abs(x-bins)))))
cols = rep(NA, length(counts.by.id))
cols[!is.na(bin)] = pal[bin[!is.na(bin)]]
## -- color markers /-- 

```

```{r ecoregion_plots, echo=FALSE, warning=FALSE, message=FALSE, eval=TRUE, fig.height=3.5, fig.width=5.2}
layout(matrix(data = c(1,1,1,1,1,1,2), ncol=1))
par(mai = c(0,0,0,0), omi = c(0,0,0,0))

xlim <- c(-1534607.9,2050000.1) # specific to the transform we are using
ylim <- c(-2072574.6,727758.7)

plot(eco, add = FALSE, col = cols, border = 'grey35', lwd = 0.5, xlim = xlim, ylim = ylim)
plot(sp2, add = TRUE, col=site.color, pch=20, cex=0.5)


# secondary plot for color legend
plot(c(NA,NA),c(NA,NA), axes=F, ylim=c(0,1),xlim=c(0,1))
bin.w = 0.07
spc = .02
text(.1,.5, 'Number of sites', pos=3, offset=0.1)
for(i in 1:length(key.cols)){
  x1 = 0.20+(i-1)*(bin.w+spc)
  graphics::rect(x1, 0.3, x1+bin.w, 0.8, col=key.cols[i], lwd=NA)
  text(x1+bin.w/2, y=0.33, labels=key.bins[i], pos=1)
}
## -- plot map /-- 

```
